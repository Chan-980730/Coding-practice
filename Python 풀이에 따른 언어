파이썬의 기본 구조 - def로 시작되는 명령어는 사용자 정의 함수, class로 시작되는 명령어는 클래스 / def와 class를 제거하였을 때 남아있는 명령어들을 순차적으로 실행
- 파이썬 기본 구조
print('A') : A를 출력 -> A

- 파이썬 기본자료형
print(A+B) : A+B를 출력 (print 안에서 연산 가능 / 정수형, 실수형 조합가능) -> A+B
print(true) : 참값인 True를 출력 ----------> 참값인 True? 그냥 True가 출력되는건지 아니면 결과값이 참값일 때 True가 출력되는건지

- 파이썬 문자열형
print("W"A"W") : 큰따옴표를 포함하여 문자열 A 출력 -> "A"
print("A"*3) : 문자열 A 3번 출력 -> AAA
print("A", "B") : 파이썬에서 print안에 ,(콤마)로 구분될 경우 띄어쓰기가 됨 -> A B
* 파이썬에서 문자열은 큰따옴표로 나타내기 때문에 큰따옴표를 사용하고 싶은 경우 C언어처럼 이스케이프 문자인 \를 사용하여 \"로 씀

- 파이썬 문자열 포맷스트링 출력 ----------> 포맷 스트링이란? -> 포맷 스트링 공격 : 프로그램에 입력된 문자열 데이터가 명령으로 해석될 떄 발생
a = "A" : A를 문자열 a에 대입 ----------> 대입이라는 개념은 수학적인 개념으로 긴 함수를 줄여서 편하게 쓰려고 하는 것인가?
print("%s" % a) : 포맷 스트링 %s에 a 문자열 A를 전달하여 출력 -> A ----------> 포맷 스트링 %s란 무엇인가? -> 문자열 포맷을 설정하는데 사용하는 인자
b = "%s" % "B" : %s와 문자열 B를 b에 대입
print(a+b) : a와 b를 연결한 A B를 출력 (문자열이기 때문에 띄어쓰기만 추가돼서 출력됨)
c = 123 : C에 정수 123을 대입
print("%s %d" % (a,c)) : %s에는 a, %d에는 c가 매핑되어 A 123이 출력 ----------> %d는 어디서 나온건가? -> 문자열 포맷을 설정하는데 사용하는 인자 / 코딩에서 띄어쓰기와 ""는 항상 의미가 있는가?

- 파이썬 문자열 in
in : 찾고자 하는 문자열이 존재하면 True, 없으면 False를 리턴함
print("A" in "ABC") : ABC안에 A가 존재하므로 True 출력 -> True
print("A" in "BCD") : BCD안에 A가 존재하지 않으므로 False 출력 -> False

- 문자열 관련 메서드 ----------> 메서드란 무엇인가? 우리나라 단어처럼 그럼 형태?
upper() : 문자열을 대문자로 변환하는 메서드
lower() : 문자열을 소문자로 변환하는 메서드
isalnum() : 문자열이 알파벳 또는 숫자로만 구성되어 있으면 True, 아니면 False를 리턴하는 메서드
isalpha() : 문자열이 알파벳으로만 구성되어 있으면 True, 아니면 False를 리턴하는 메서드
isdecimal() : 문자열이 정수이면 True, 아니면 False를 리턴하는 메서드
isdigit() : 문자열이 숫자이면 True, 아니면 False를 리턴하는 메서드
isspace() : 문자열이 공백으로만 구성되어 있으면 True, 아니면 False를 리턴하는 메서드
split() : 문자열을 매개변수로 전달된 문자(구분자)로 나누어 리스트로 변환하는 메서드 Ex) split(sep='A') : 구분자인 A를 기준으로 분리
* is가 앞에 들어가면 True 혹은 False를 출력하는 것 같음
* 파이썬에서 컬렉션 자료형 변수를 그냥 출력했을 때는 괄호가 표시되지만, 문자열 변수를 출력했을 때는 괄호가 표시되지 않음

- 파이썬 문자열(str) 메서드
a = "Ab 123" : a라는 이름의 변수에 문자열 "Ab 123"를 대입
print(a.upper()) : a를 대문자로 변환한 값을 출력 -> AB 123
print(a.lower()) : a를 소문자로 변환한 값을 출력 -> ab 123
print(a.isalnum()) : a가 알파벳 또는 숫자로만 구성되어 있으면 True, 아니면 False -> False
print(a.isalpha()) : a가 알파벳으로만 구성되어 있으면 True, 아니면 False -> False
print(a.isdecimal()) : a가 정수이면 True, 아니면 False -> False
print(a.isdigit()) : a가 숫자이면 True, 아니면 False -> False
print(a.inspace()) : a가 공백으로만 구성되어 있으면 True, 아니면 False -> False
print(a.split()) : a를 구분자로 분리 (구분자가 지정되어 있지 않으므로 띄어쓰기를 기준으로 분리) -> ['Ab', '123']
print(a.split(sep='1')) : a를 구분자인 '1'을 기준으로 분리 -> ['Ab', '23']
str = "1,2,3".split(",") : 문자열 "1,2,3"에서 ,(콤마)를 기준으로 나눠서 리스트로 생성 ----------> str은 리스트를 생성하는 것인가? 아니면 대입되는 것인가? 아니면 가장 위의 설명처럼 문자열을 나타내는 것인가?
print(str) : str을 출력 -> ['1', '2', '3'] 

- 리스트형 메서드
append(x) : 리스트 마지막 요소 뒤에 값 x를 추가하는 메서드 -> 단위 같은 것을 사용할 때 적절해보임 Ex) 원, kg 등
clear() : 리스트의 모든 항목을 삭제하는 메서드
copy() : 리스트를 복사하는 메서드
count(x) : 리스트에서 x 항목의 개수를 알려주는 메서드
extend(i) : 리스트 마지막에 컬렉션 자료형 i를 추가하는 메서드 ----------> 그렇다면 append와 extend 중 어떤 것이 더 우선이 될까? 둘의 순서?
index(x) : 값 x와 같은 값을 가지고 있는 인덱스 번호를 알려주는 메서드
insert(i, x) : 리스트의 i번지 위치에 값 x를 삽입하는 메서드
pop() : 마지막 항목을 삭제하고 값을 꺼내오는 메서드 ----------> 꺼내온다는 개념이 잘라내기?
remove(x) : 리스트에서 해당하는 값 x를 제거하는 메서드 / 해당하는 값이 여러 개 있을 경우 가장 앞에 있는 값을 제거
reverse() : 리스트의 위치를 전부 역순으로 바꿔주는 메서드
sort() : 리스트의 항목들을 정렬하는 메서드

- 파이썬 리스트형 메서드
a = [20, 10, 30] : 리스트 a 선언 및 20, 10, 30으로 초기화 ----------> 선언이라는 개념? 별로 신경안써도 되나?
print(a) : 리스트에 저장된 [20, 10, 30]을 출력 -> [20, 10, 30]
a.extend(a) : 리스트를 확장하여 20, 10, 30을 한 번에 추가함
print(a) : 리스트 a에 저장된 [20, 10, 30, 20, 10, 30]을 출력 -> [20, 10, 30, 20, 10, 30}
a.pop() : 리스트 마지막 또는 지정 요소를 삭제하고 그 값을 반환함 (지정 요소가 없기 때문에 마지막 30을 삭제하고 반환) ----------> 반환은 어디에?
print(a) -> [20, 10, 30, 20, 10]
a.reverse() : 리스트를 역순으로 출력
print(a) -> [10, 20, 30, 10, 20]
* 파이썬에서 문자열형을 뺀 컬렉션 자료형들은 변수를 그냥 출력할 경우 괄호가 포함됨

- 파이썬 리스트형 메서드 (추가/제거)
l = [3, 5, 7] : l이라는 변수에 3, 5, 7 값을 리스트형으로 초기화
l.append(3) : l의 맨 뒤에 3을 추가
print(l) -> [3, 5, 7, 3]
l.insert(2, 4) : l의 2번지에 4라는 값을 추가(2번지는 세번째 값이므로 세번째에 4 추가) ----------> 번지당 몇번째인지?
print(l) -> [3, 5, 4, 7, 3]
l.remove(3) : l에서 3을 제거하는데 3은 두 개이므로 앞의 3이 지워짐
print(l) -> [5, 4, 7, 3]

- 파이썬 2차원 리스트
a = [[1, 2], [3, 4], [5, 6]] -> 2차원 리스트 a를 선언 및 초기화
print(a) -> [[1, 2], [3, 4], [5,6]]dho
print(a[0]) : a[0]은 [1,2], a[1]은 [3, 4], a[3]은 [5, 6]을 가리킴 -> [1, 2] ----------> 왜 [0, 1, 2]가 저런 순서로 되는 것인가? : 0이 첫번째, 1이 두번째, 2가 세번째
print(a[1][0]) -> 3 ----------> 여기는 왜 괄호가 들어가지 않는가? : 컬렉션형/리스트형 자료가 아니라서
b = [[1, 2, 3], [4, 5], [6, 7, 8, 9]] : 2차원 리스트 b를 선언 및 초기화
print(b[0]) -> [1, 2, 3]

- 파이썬 튜플
* 튜플혀은 초기에 선언된 값에서 값을 생성, 삭제, 수정이 불가능한 형태의 자료형
t = ('s', 'j', 'b') : 튜플 변수 t에 's', 'j', 'b'로 초기화
print(t) -> ('s', 'j', 'b')

- 시퀸스 자료형 요소 접근 방법
Ex) a = [4, 2, 7, 3, 5]
4 -> a[0] ----------> a[-5]도 가능?
2 -> a[1], a[-4]
7 -> a[2], a[-3]
3 -> a[3], a[-2]
5 -> a[4], a[-1]
* 문자열 앞에서부터 시작하면 인덱스는 0부터 시작하고, 뒤에서부터 시작하면 -1부터 시작

print("soojebi"[3]) -> j
print("soojebi"[-7]) -> s
str = "soojebi" : 문자열 soojebi를 str이라는 변수에 대입
print(str[1]) : 문자열 str은 문자열 soojebi이므로 1번째 문자인 o를 출력 -> o ----------> ""들은 개수로 치지 않는지?

- 파이썬 튜플 인덱싱
t = ('s', 'j', 'b') : 튜플 변수 t에 's', 'j', 'b'로 초기화
print(t[0]) -> s

- 시퀀스 자료형 요소 접근 방법 - 슬라이싱(여러 개의 데이터에 동시에 접근하는 기법)
* 시퀀스변수명[시작:종료:스텝]
* 슬라이싱을 통해 출력할 때는 괄호가 표시됨 / 단, 문자열 슬라이싱은 다른 시퀀스 자료형과 다르게 출력 결과에 괄호가 표시되지 않음

- 파이썬 문자열 슬라이싱
print("soojebi"[1:]) : 시작 위치만 지정하면 뒤로 쭉 출력 -> oojebi
print("soojebi"[2:4]) : 2번째부터 시작해서 3번째(4-1번째)까지 출력하며, step은 생략되므로 1이 되어 출력 -> oj
print("soojebi"[:3]) : 시작 인덱스는 생략되어 있고, 종료 인덱스만 명시된 형태로 2번째(3-1번째)까지 출력 -> soo

- 파이썬 리스트 슬라이싱
a = [4, 2, 7, 3, 5] : 리스트 a에 4, 2, 7, 3, 5로 초기화
print(a[0 : 4 : 2]) : 0번지부터 3번지(4-1번지) 인덱스까지 2개씩 끊어서 슬라이싱 -> [4, 7] ----------> 끊어서 슬라이싱 한다는 의미가 스텝번째마다 빼고 출력?

- 파이썬 튜플 슬라이싱
t = ('s', 'j', 'b') : 튜플 변수 t에 's', 'j', 'b'로 초기화
print(t[1:]) : 튜플 변수 t를 슬라이싱하여 출력 -> ('j', 'b')

- 시퀀스 자료형 연산자 (연결, 반복 연산자)
  + : 두 시퀀스 자료형을 연결하는 연산자
  * : 시퀀스 자료형을 반복하는 연산자
a = [1, 2, 3]
b = [4, 5, 6]
print(a + b) : 연산자 +를 사용하여 a 리스트와 b 리스트를 연결한 값인 [1, 2, 3, 4, 5, 6]을 출력 -> [1, 2, 3, 4, 5, 6] ----------> a + b 라서 a 다음 b가 나오는 순서?
print(a*3) : 연산자 *를 사용하여 a 리스트를 3번 반복하여 출력 -> [1, 2, 3, 1, 2, 3, 1, 2, 3]

- 시퀀스 자료형 연산자 (in, not in 연산자)
  in : 리스트 내부의 특정 값이 존재하는지 확인하는 연산자
  not in : 리스트 내부의 특정 값이 존재하지 않는지 확인하는 연산자

- 리스트 in, not in 연산자
a = [1, 2, 3, 4, 5] : a 변수에 리스트 [1, 2, 3, 4, 5]를 대입
1 in a : a 리스트 내부에 1이 있으므로 True -> True
7 in a : a 리스트 내부에 7이 없으므로 False -> False
8 not in a : a 리스트 내부에 8이 없으므로 True -> True

- 비시퀀스 자료형 구조
* 순서가 존재하지 않는 자료형으로 순서가 중요하지 않음

- 파이썬 세트형
s = {1, 5, 7} : s라는 변수에 1, 5, 7 값을 세트형으로 초기화 ----------> [], (), {}는 다 다르게 사용해줘야 하는가?
s.add(3) : s에 3이 없으므로 3 추가
print(s) -> {1, 3, 5, 7}
s.add(5) : s에 5를 추가하지만 이미 5가 있으므로 변화없음
print(s) -> {1, 3, 5, 7} 
s.update([1, 2, 3, 4]) : s에 1, 2, 3, 4를 한 번에 추가하지만 1, 3은 이미 있으므로 2, 4만 추가
print(s) -> {1, 2, 3, 4, 5, 7}
s.remove(1) : s에서 1을 제거
print(s) -> {2, 3, 4, 5, 7}

- 딕셔너리 (키와 값으로 구선된 객체를 저장하는 구조로 되어있는 자료형)
생성 : 딕셔너리명 = {키1:값1, 키2:값2, ...}
변경 : 딕셔너리명[키] = 값
삭제 : del 딕셔너리명[키]
d = {'A':5, 'C':4} : d라는 변수에 키가 A일 때 값을 5로, C일 때 값을 4로 초기화
print(d) -> {'A':5, 'C':4}
d['K'] = 7 : d라는 변수에 키가 K일 때 값을 7로 저장
print(d) -> {'A':5, 'C':4, 'K':7}
del d['C'] : d라는 변수에 키가 C에 해당하는 값을 삭제
print(d) -> {'A':5, 'K':7}
d['K'] = 6 : d라는 변수에 키가 K일 때 값을 6으로 저장 (기존에 키가 K일 때 값이 7에서 6으로 변경)
print(d) -> {'A':5, 'K':6}

- type 함수
기본 자료형 : 정수형-class 'int', 실수형-class 'float', 논리형-class 'bool'
컬렉션 자료형 : 문자열형-class 'str', 리스트형-class 'list', 튜플형-class 'tuple', 딕셔너리형-class 'dict', 세트형-class 'set'

- 파이썬 type 함수 자료형 확인


